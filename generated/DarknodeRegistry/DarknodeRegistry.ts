// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class LogDarknodeDeregistered extends EthereumEvent {
  get params(): LogDarknodeDeregistered__Params {
    return new LogDarknodeDeregistered__Params(this);
  }
}

export class LogDarknodeDeregistered__Params {
  _event: LogDarknodeDeregistered;

  constructor(event: LogDarknodeDeregistered) {
    this._event = event;
  }

  get _operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _darknodeID(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LogDarknodeOwnerRefunded extends EthereumEvent {
  get params(): LogDarknodeOwnerRefunded__Params {
    return new LogDarknodeOwnerRefunded__Params(this);
  }
}

export class LogDarknodeOwnerRefunded__Params {
  _event: LogDarknodeOwnerRefunded;

  constructor(event: LogDarknodeOwnerRefunded) {
    this._event = event;
  }

  get _operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class LogDarknodePaymentUpdated extends EthereumEvent {
  get params(): LogDarknodePaymentUpdated__Params {
    return new LogDarknodePaymentUpdated__Params(this);
  }
}

export class LogDarknodePaymentUpdated__Params {
  _event: LogDarknodePaymentUpdated;

  constructor(event: LogDarknodePaymentUpdated) {
    this._event = event;
  }

  get _previousDarknodePayment(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _nextDarknodePayment(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LogDarknodeRegistered extends EthereumEvent {
  get params(): LogDarknodeRegistered__Params {
    return new LogDarknodeRegistered__Params(this);
  }
}

export class LogDarknodeRegistered__Params {
  _event: LogDarknodeRegistered;

  constructor(event: LogDarknodeRegistered) {
    this._event = event;
  }

  get _operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _darknodeID(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _bond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class LogDarknodeSlashed extends EthereumEvent {
  get params(): LogDarknodeSlashed__Params {
    return new LogDarknodeSlashed__Params(this);
  }
}

export class LogDarknodeSlashed__Params {
  _event: LogDarknodeSlashed;

  constructor(event: LogDarknodeSlashed) {
    this._event = event;
  }

  get _operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _darknodeID(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _challenger(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get _percentage(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class LogMinimumBondUpdated extends EthereumEvent {
  get params(): LogMinimumBondUpdated__Params {
    return new LogMinimumBondUpdated__Params(this);
  }
}

export class LogMinimumBondUpdated__Params {
  _event: LogMinimumBondUpdated;

  constructor(event: LogMinimumBondUpdated) {
    this._event = event;
  }

  get _previousMinimumBond(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _nextMinimumBond(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class LogMinimumEpochIntervalUpdated extends EthereumEvent {
  get params(): LogMinimumEpochIntervalUpdated__Params {
    return new LogMinimumEpochIntervalUpdated__Params(this);
  }
}

export class LogMinimumEpochIntervalUpdated__Params {
  _event: LogMinimumEpochIntervalUpdated;

  constructor(event: LogMinimumEpochIntervalUpdated) {
    this._event = event;
  }

  get _previousMinimumEpochInterval(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _nextMinimumEpochInterval(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class LogMinimumPodSizeUpdated extends EthereumEvent {
  get params(): LogMinimumPodSizeUpdated__Params {
    return new LogMinimumPodSizeUpdated__Params(this);
  }
}

export class LogMinimumPodSizeUpdated__Params {
  _event: LogMinimumPodSizeUpdated;

  constructor(event: LogMinimumPodSizeUpdated) {
    this._event = event;
  }

  get _previousMinimumPodSize(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _nextMinimumPodSize(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class LogNewEpoch extends EthereumEvent {
  get params(): LogNewEpoch__Params {
    return new LogNewEpoch__Params(this);
  }
}

export class LogNewEpoch__Params {
  _event: LogNewEpoch;

  constructor(event: LogNewEpoch) {
    this._event = event;
  }

  get epochhash(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class LogSlasherUpdated extends EthereumEvent {
  get params(): LogSlasherUpdated__Params {
    return new LogSlasherUpdated__Params(this);
  }
}

export class LogSlasherUpdated__Params {
  _event: LogSlasherUpdated;

  constructor(event: LogSlasherUpdated) {
    this._event = event;
  }

  get _previousSlasher(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _nextSlasher(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnershipTransferred extends EthereumEvent {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class DarknodeRegistry__currentEpochResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class DarknodeRegistry__previousEpochResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class DarknodeRegistry extends SmartContract {
  static bind(address: Address): DarknodeRegistry {
    return new DarknodeRegistry("DarknodeRegistry", address);
  }

  VERSION(): string {
    let result = super.call("VERSION", []);

    return result[0].toString();
  }

  try_VERSION(): CallResult<string> {
    let result = super.tryCall("VERSION", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toString());
  }

  currentEpoch(): DarknodeRegistry__currentEpochResult {
    let result = super.call("currentEpoch", []);

    return new DarknodeRegistry__currentEpochResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_currentEpoch(): CallResult<DarknodeRegistry__currentEpochResult> {
    let result = super.tryCall("currentEpoch", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new DarknodeRegistry__currentEpochResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  darknodePayment(): Address {
    let result = super.call("darknodePayment", []);

    return result[0].toAddress();
  }

  try_darknodePayment(): CallResult<Address> {
    let result = super.tryCall("darknodePayment", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  getDarknodeBond(_darknodeID: Address): BigInt {
    let result = super.call("getDarknodeBond", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBigInt();
  }

  try_getDarknodeBond(_darknodeID: Address): CallResult<BigInt> {
    let result = super.tryCall("getDarknodeBond", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getDarknodeOwner(_darknodeID: Address): Address {
    let result = super.call("getDarknodeOwner", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toAddress();
  }

  try_getDarknodeOwner(_darknodeID: Address): CallResult<Address> {
    let result = super.tryCall("getDarknodeOwner", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  getDarknodePublicKey(_darknodeID: Address): Bytes {
    let result = super.call("getDarknodePublicKey", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBytes();
  }

  try_getDarknodePublicKey(_darknodeID: Address): CallResult<Bytes> {
    let result = super.tryCall("getDarknodePublicKey", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  getDarknodes(_start: Address, _count: BigInt): Array<Address> {
    let result = super.call("getDarknodes", [
      EthereumValue.fromAddress(_start),
      EthereumValue.fromUnsignedBigInt(_count)
    ]);

    return result[0].toAddressArray();
  }

  try_getDarknodes(
    _start: Address,
    _count: BigInt
  ): CallResult<Array<Address>> {
    let result = super.tryCall("getDarknodes", [
      EthereumValue.fromAddress(_start),
      EthereumValue.fromUnsignedBigInt(_count)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddressArray());
  }

  getPreviousDarknodes(_start: Address, _count: BigInt): Array<Address> {
    let result = super.call("getPreviousDarknodes", [
      EthereumValue.fromAddress(_start),
      EthereumValue.fromUnsignedBigInt(_count)
    ]);

    return result[0].toAddressArray();
  }

  try_getPreviousDarknodes(
    _start: Address,
    _count: BigInt
  ): CallResult<Array<Address>> {
    let result = super.tryCall("getPreviousDarknodes", [
      EthereumValue.fromAddress(_start),
      EthereumValue.fromUnsignedBigInt(_count)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddressArray());
  }

  isDeregisterable(_darknodeID: Address): boolean {
    let result = super.call("isDeregisterable", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isDeregisterable(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isDeregisterable", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isDeregistered(_darknodeID: Address): boolean {
    let result = super.call("isDeregistered", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isDeregistered(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isDeregistered", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isOwner(): boolean {
    let result = super.call("isOwner", []);

    return result[0].toBoolean();
  }

  try_isOwner(): CallResult<boolean> {
    let result = super.tryCall("isOwner", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isPendingDeregistration(_darknodeID: Address): boolean {
    let result = super.call("isPendingDeregistration", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isPendingDeregistration(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isPendingDeregistration", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isPendingRegistration(_darknodeID: Address): boolean {
    let result = super.call("isPendingRegistration", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isPendingRegistration(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isPendingRegistration", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isRefundable(_darknodeID: Address): boolean {
    let result = super.call("isRefundable", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isRefundable(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isRefundable", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isRefunded(_darknodeID: Address): boolean {
    let result = super.call("isRefunded", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isRefunded(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isRefunded", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isRegistered(_darknodeID: Address): boolean {
    let result = super.call("isRegistered", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isRegistered(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isRegistered", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isRegisteredInPreviousEpoch(_darknodeID: Address): boolean {
    let result = super.call("isRegisteredInPreviousEpoch", [
      EthereumValue.fromAddress(_darknodeID)
    ]);

    return result[0].toBoolean();
  }

  try_isRegisteredInPreviousEpoch(_darknodeID: Address): CallResult<boolean> {
    let result = super.tryCall("isRegisteredInPreviousEpoch", [
      EthereumValue.fromAddress(_darknodeID)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  minimumBond(): BigInt {
    let result = super.call("minimumBond", []);

    return result[0].toBigInt();
  }

  try_minimumBond(): CallResult<BigInt> {
    let result = super.tryCall("minimumBond", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  minimumEpochInterval(): BigInt {
    let result = super.call("minimumEpochInterval", []);

    return result[0].toBigInt();
  }

  try_minimumEpochInterval(): CallResult<BigInt> {
    let result = super.tryCall("minimumEpochInterval", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  minimumPodSize(): BigInt {
    let result = super.call("minimumPodSize", []);

    return result[0].toBigInt();
  }

  try_minimumPodSize(): CallResult<BigInt> {
    let result = super.tryCall("minimumPodSize", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  nextMinimumBond(): BigInt {
    let result = super.call("nextMinimumBond", []);

    return result[0].toBigInt();
  }

  try_nextMinimumBond(): CallResult<BigInt> {
    let result = super.tryCall("nextMinimumBond", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  nextMinimumEpochInterval(): BigInt {
    let result = super.call("nextMinimumEpochInterval", []);

    return result[0].toBigInt();
  }

  try_nextMinimumEpochInterval(): CallResult<BigInt> {
    let result = super.tryCall("nextMinimumEpochInterval", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  nextMinimumPodSize(): BigInt {
    let result = super.call("nextMinimumPodSize", []);

    return result[0].toBigInt();
  }

  try_nextMinimumPodSize(): CallResult<BigInt> {
    let result = super.tryCall("nextMinimumPodSize", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  nextSlasher(): Address {
    let result = super.call("nextSlasher", []);

    return result[0].toAddress();
  }

  try_nextSlasher(): CallResult<Address> {
    let result = super.tryCall("nextSlasher", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  numDarknodes(): BigInt {
    let result = super.call("numDarknodes", []);

    return result[0].toBigInt();
  }

  try_numDarknodes(): CallResult<BigInt> {
    let result = super.tryCall("numDarknodes", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  numDarknodesNextEpoch(): BigInt {
    let result = super.call("numDarknodesNextEpoch", []);

    return result[0].toBigInt();
  }

  try_numDarknodesNextEpoch(): CallResult<BigInt> {
    let result = super.tryCall("numDarknodesNextEpoch", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  numDarknodesPreviousEpoch(): BigInt {
    let result = super.call("numDarknodesPreviousEpoch", []);

    return result[0].toBigInt();
  }

  try_numDarknodesPreviousEpoch(): CallResult<BigInt> {
    let result = super.tryCall("numDarknodesPreviousEpoch", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", []);

    return result[0].toAddress();
  }

  try_owner(): CallResult<Address> {
    let result = super.tryCall("owner", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  previousEpoch(): DarknodeRegistry__previousEpochResult {
    let result = super.call("previousEpoch", []);

    return new DarknodeRegistry__previousEpochResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_previousEpoch(): CallResult<DarknodeRegistry__previousEpochResult> {
    let result = super.tryCall("previousEpoch", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new DarknodeRegistry__previousEpochResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  ren(): Address {
    let result = super.call("ren", []);

    return result[0].toAddress();
  }

  try_ren(): CallResult<Address> {
    let result = super.tryCall("ren", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  slasher(): Address {
    let result = super.call("slasher", []);

    return result[0].toAddress();
  }

  try_slasher(): CallResult<Address> {
    let result = super.tryCall("slasher", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  store(): Address {
    let result = super.call("store", []);

    return result[0].toAddress();
  }

  try_store(): CallResult<Address> {
    let result = super.tryCall("store", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends EthereumCall {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _VERSION(): string {
    return this._call.inputValues[0].value.toString();
  }

  get _renAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _storeAddress(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _minimumBond(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _minimumPodSize(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _minimumEpochIntervalSeconds(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ClaimOwnershipCall extends EthereumCall {
  get inputs(): ClaimOwnershipCall__Inputs {
    return new ClaimOwnershipCall__Inputs(this);
  }

  get outputs(): ClaimOwnershipCall__Outputs {
    return new ClaimOwnershipCall__Outputs(this);
  }
}

export class ClaimOwnershipCall__Inputs {
  _call: ClaimOwnershipCall;

  constructor(call: ClaimOwnershipCall) {
    this._call = call;
  }
}

export class ClaimOwnershipCall__Outputs {
  _call: ClaimOwnershipCall;

  constructor(call: ClaimOwnershipCall) {
    this._call = call;
  }
}

export class ClaimStoreOwnershipCall extends EthereumCall {
  get inputs(): ClaimStoreOwnershipCall__Inputs {
    return new ClaimStoreOwnershipCall__Inputs(this);
  }

  get outputs(): ClaimStoreOwnershipCall__Outputs {
    return new ClaimStoreOwnershipCall__Outputs(this);
  }
}

export class ClaimStoreOwnershipCall__Inputs {
  _call: ClaimStoreOwnershipCall;

  constructor(call: ClaimStoreOwnershipCall) {
    this._call = call;
  }
}

export class ClaimStoreOwnershipCall__Outputs {
  _call: ClaimStoreOwnershipCall;

  constructor(call: ClaimStoreOwnershipCall) {
    this._call = call;
  }
}

export class DeregisterCall extends EthereumCall {
  get inputs(): DeregisterCall__Inputs {
    return new DeregisterCall__Inputs(this);
  }

  get outputs(): DeregisterCall__Outputs {
    return new DeregisterCall__Outputs(this);
  }
}

export class DeregisterCall__Inputs {
  _call: DeregisterCall;

  constructor(call: DeregisterCall) {
    this._call = call;
  }

  get _darknodeID(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DeregisterCall__Outputs {
  _call: DeregisterCall;

  constructor(call: DeregisterCall) {
    this._call = call;
  }
}

export class EpochCall extends EthereumCall {
  get inputs(): EpochCall__Inputs {
    return new EpochCall__Inputs(this);
  }

  get outputs(): EpochCall__Outputs {
    return new EpochCall__Outputs(this);
  }
}

export class EpochCall__Inputs {
  _call: EpochCall;

  constructor(call: EpochCall) {
    this._call = call;
  }
}

export class EpochCall__Outputs {
  _call: EpochCall;

  constructor(call: EpochCall) {
    this._call = call;
  }
}

export class RecoverTokensCall extends EthereumCall {
  get inputs(): RecoverTokensCall__Inputs {
    return new RecoverTokensCall__Inputs(this);
  }

  get outputs(): RecoverTokensCall__Outputs {
    return new RecoverTokensCall__Outputs(this);
  }
}

export class RecoverTokensCall__Inputs {
  _call: RecoverTokensCall;

  constructor(call: RecoverTokensCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RecoverTokensCall__Outputs {
  _call: RecoverTokensCall;

  constructor(call: RecoverTokensCall) {
    this._call = call;
  }
}

export class RefundCall extends EthereumCall {
  get inputs(): RefundCall__Inputs {
    return new RefundCall__Inputs(this);
  }

  get outputs(): RefundCall__Outputs {
    return new RefundCall__Outputs(this);
  }
}

export class RefundCall__Inputs {
  _call: RefundCall;

  constructor(call: RefundCall) {
    this._call = call;
  }

  get _darknodeID(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RefundCall__Outputs {
  _call: RefundCall;

  constructor(call: RefundCall) {
    this._call = call;
  }
}

export class RegisterCall extends EthereumCall {
  get inputs(): RegisterCall__Inputs {
    return new RegisterCall__Inputs(this);
  }

  get outputs(): RegisterCall__Outputs {
    return new RegisterCall__Outputs(this);
  }
}

export class RegisterCall__Inputs {
  _call: RegisterCall;

  constructor(call: RegisterCall) {
    this._call = call;
  }

  get _darknodeID(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _publicKey(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class RegisterCall__Outputs {
  _call: RegisterCall;

  constructor(call: RegisterCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends EthereumCall {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SlashCall extends EthereumCall {
  get inputs(): SlashCall__Inputs {
    return new SlashCall__Inputs(this);
  }

  get outputs(): SlashCall__Outputs {
    return new SlashCall__Outputs(this);
  }
}

export class SlashCall__Inputs {
  _call: SlashCall;

  constructor(call: SlashCall) {
    this._call = call;
  }

  get _guilty(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _challenger(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _percentage(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SlashCall__Outputs {
  _call: SlashCall;

  constructor(call: SlashCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends EthereumCall {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class TransferStoreOwnershipCall extends EthereumCall {
  get inputs(): TransferStoreOwnershipCall__Inputs {
    return new TransferStoreOwnershipCall__Inputs(this);
  }

  get outputs(): TransferStoreOwnershipCall__Outputs {
    return new TransferStoreOwnershipCall__Outputs(this);
  }
}

export class TransferStoreOwnershipCall__Inputs {
  _call: TransferStoreOwnershipCall;

  constructor(call: TransferStoreOwnershipCall) {
    this._call = call;
  }

  get _newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferStoreOwnershipCall__Outputs {
  _call: TransferStoreOwnershipCall;

  constructor(call: TransferStoreOwnershipCall) {
    this._call = call;
  }
}

export class UpdateDarknodePaymentCall extends EthereumCall {
  get inputs(): UpdateDarknodePaymentCall__Inputs {
    return new UpdateDarknodePaymentCall__Inputs(this);
  }

  get outputs(): UpdateDarknodePaymentCall__Outputs {
    return new UpdateDarknodePaymentCall__Outputs(this);
  }
}

export class UpdateDarknodePaymentCall__Inputs {
  _call: UpdateDarknodePaymentCall;

  constructor(call: UpdateDarknodePaymentCall) {
    this._call = call;
  }

  get _darknodePayment(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateDarknodePaymentCall__Outputs {
  _call: UpdateDarknodePaymentCall;

  constructor(call: UpdateDarknodePaymentCall) {
    this._call = call;
  }
}

export class UpdateMinimumBondCall extends EthereumCall {
  get inputs(): UpdateMinimumBondCall__Inputs {
    return new UpdateMinimumBondCall__Inputs(this);
  }

  get outputs(): UpdateMinimumBondCall__Outputs {
    return new UpdateMinimumBondCall__Outputs(this);
  }
}

export class UpdateMinimumBondCall__Inputs {
  _call: UpdateMinimumBondCall;

  constructor(call: UpdateMinimumBondCall) {
    this._call = call;
  }

  get _nextMinimumBond(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class UpdateMinimumBondCall__Outputs {
  _call: UpdateMinimumBondCall;

  constructor(call: UpdateMinimumBondCall) {
    this._call = call;
  }
}

export class UpdateMinimumEpochIntervalCall extends EthereumCall {
  get inputs(): UpdateMinimumEpochIntervalCall__Inputs {
    return new UpdateMinimumEpochIntervalCall__Inputs(this);
  }

  get outputs(): UpdateMinimumEpochIntervalCall__Outputs {
    return new UpdateMinimumEpochIntervalCall__Outputs(this);
  }
}

export class UpdateMinimumEpochIntervalCall__Inputs {
  _call: UpdateMinimumEpochIntervalCall;

  constructor(call: UpdateMinimumEpochIntervalCall) {
    this._call = call;
  }

  get _nextMinimumEpochInterval(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class UpdateMinimumEpochIntervalCall__Outputs {
  _call: UpdateMinimumEpochIntervalCall;

  constructor(call: UpdateMinimumEpochIntervalCall) {
    this._call = call;
  }
}

export class UpdateMinimumPodSizeCall extends EthereumCall {
  get inputs(): UpdateMinimumPodSizeCall__Inputs {
    return new UpdateMinimumPodSizeCall__Inputs(this);
  }

  get outputs(): UpdateMinimumPodSizeCall__Outputs {
    return new UpdateMinimumPodSizeCall__Outputs(this);
  }
}

export class UpdateMinimumPodSizeCall__Inputs {
  _call: UpdateMinimumPodSizeCall;

  constructor(call: UpdateMinimumPodSizeCall) {
    this._call = call;
  }

  get _nextMinimumPodSize(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class UpdateMinimumPodSizeCall__Outputs {
  _call: UpdateMinimumPodSizeCall;

  constructor(call: UpdateMinimumPodSizeCall) {
    this._call = call;
  }
}

export class UpdateSlasherCall extends EthereumCall {
  get inputs(): UpdateSlasherCall__Inputs {
    return new UpdateSlasherCall__Inputs(this);
  }

  get outputs(): UpdateSlasherCall__Outputs {
    return new UpdateSlasherCall__Outputs(this);
  }
}

export class UpdateSlasherCall__Inputs {
  _call: UpdateSlasherCall;

  constructor(call: UpdateSlasherCall) {
    this._call = call;
  }

  get _slasher(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpdateSlasherCall__Outputs {
  _call: UpdateSlasherCall;

  constructor(call: UpdateSlasherCall) {
    this._call = call;
  }
}
